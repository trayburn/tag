########################
Had to install mysql ...

start mysql via 'sudo systemctl start mysql'

to start on a reboot: `sudo systemctl enable mysql`

After installing, reset the root password for mysql via https://devanswers.co/how-to-reset-mysql-root-password-ubuntu/
I set it to "password"

Set our user (dr_j) with a password (supertopsecretpassw0rd) via
https://www.a2hosting.com/kb/developer-corner/mysql/managing-mysql-databases-and-users-from-the-command-line
#########################

Had to modify pom, adding source and target levels (so not just release):

    <properties>
        <maven.compiler.release>11</maven.compiler.release>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

Otherwise, the openjdk from amazon wouldn't work (or maybe it's my version of maven?)

#########################

Modified the TagWorldCreate.sql, adding "IF EXISTS" to delete tables initially.
Otherwise, rerunning the the entire script wouldn't work (would fail if the tables didn't exist)

#########################

SpringContext.java --- had to add my username and password.

#########################

Added some entries to .gitignore so I don't commit Eclipse files.

#########################

And, after some stumbling, having Eclipse not able to push or pull, I realized I had to add github.com to my ~/.ssh/config file. 8^)





pom.xml changes ...

persistence.xml <--- configures hibernate, lists all the persistent entities

JPAUtility.java <--- get the entity manager for our "persistence unit"

Adversary.java
    -- Add @Entity (get the table name correct)
    -- Add @Id
    -- define all columns (note dropItemName is DropItem in the table)
 
    -- @Transient on dropItem field
    
    -- add a @PostLoad to set the dropItem based on the Uniqueitems
    --- basically moving functionality from the LocationDAO

    @PostLoad 
    protected void postLoad() {
            if (null != dropItemName) {
                setItem(Arrays
                        .stream(UniqueItems.values())
                        .filter(item -> item.getName().equals(dropItemName))
                        .findFirst()
                        .orElse(null)
                );
            }
    }
 
LocationDao.java

Tweak query to not return all adversary info.
Instead:

                                EntityManager em = JPAUtility.getEntityManager();
                                Adversary adversary = em.find( Adversary.class, result.getLong( "AdversaryId" ) );
                            location.setAdversary(adversary);
                            System.out.println("Set adversary " + adversary.getName() + " to location " + location.getName() );

Just get the adversary and set it.



LATER:

Code in Adversary.java about mapping to a dropItemName could be done by persisting the enum in the database.


DAY 2:

#1 Why doesn't JPAUtility work -- wonky IntelliJ; deleting class and re-adding and it worked.

Making Location persistent:

Start with Location ....
In the database, Location only has id, Name, Description, and AdversaryId.
In the existing code, the locations are read .... and then the exits are set.

Let's keep with that for now.

EXERCISE 1:  Make Location persistent via JPA ... and set the exits the way they are now.
  And keep Adversary set the way it is now.
  Basically doing the joins in Java.
  So set adversary, exits to be @Transient
  In my code, the Location.treasureChest is only set in the manually built world ... so make that @Transient too
  
  I am removing "getTags" and the "tags" attribute, as it isn't used.
  
  SQL in the entityManager.createQuery is NOT standard SQL --- it's a JPA query language
     a lot like SQL, but you reference Java objects ....
       JPQL <--- Java Persistence Query Language. https://thoughts-on-java.org/jpql/
       
     So to select all objects of type Location ....
       em.createQuery( "SELECT loc FROM org.improving.tag.Location loc" ).getResultList().
     Note the reference to the Location class in the "FROM" with the full path.
     Note this query returns List<Location> ...
     
  Only changes are in Location, LocationDAO, persistenceXML.
  
  Note that we can be lazy about transactions .... for now ... and not
  start/end transactions, and not close the entityManager.
  
Next step:

  Take Location .... and wire it to the Adversary instead of having the id
  and having us do the wiring.
  
  One Location can have One Adversary.
  But can the same Adversary appear in many Locations?
  
  @ManyToOne
  
  Easy changes ....
    Annotate adversary in Location.java as

	@ManyToOne( fetch = FetchType.EAGER )
	@JoinColumn( name="AdversaryId" )
    private Adversary adversary;

  Why eager? Because we're going to use these objects outside of a transaction, so
  we want them fully resolved.

  LocationDAO.java ... we can just remove the wiring of Adversaries to the locations.

  Lastly .... Exit. This one is interesting as it's a bidirectional relationship.
  Locations have many exits ... and the exit points to the Location it leads to.
  This is a One to Many relationship ... 
    One Location has Many Exits.
    An Exit exists in only One Location.
    
  So in Location, we have a @OneToMany relationship... and on the other side, we have @ManyToOne
  to make it bidrections.
  
  Note that we no longer need ExistsDAO at all.
  
  And ... all references to JDBC are gone.
  




Making Exits & Location persistent.
Join Tables (@JoinTable)
@ManyToMany
@OneToMany
@ManyToOne

Transactions
Lazy Loading

Day 3 - Spring-JPA

Convert everything to Spring-JPA (i.e., get rid of DAO's and use Repositories).
