########################
Had to install mysql ...

start mysql via 'sudo systemctl start mysql'

to start on a reboot: `sudo systemctl enable mysql`

After installing, reset the root password for mysql via https://devanswers.co/how-to-reset-mysql-root-password-ubuntu/
I set it to "password"

Set our user (dr_j) with a password (supertopsecretpassw0rd) via
https://www.a2hosting.com/kb/developer-corner/mysql/managing-mysql-databases-and-users-from-the-command-line
#########################

Had to modify pom, adding source and target levels (so not just release):

    <properties>
        <maven.compiler.release>11</maven.compiler.release>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

Otherwise, the openjdk from amazon wouldn't work (or maybe it's my version of maven?)

#########################

Modified the TagWorldCreate.sql, adding "IF EXISTS" to delete tables initially.
Otherwise, rerunning the the entire script wouldn't work (would fail if the tables didn't exist)

#########################

SpringContext.java --- had to add my username and password.

#########################

Added some entries to .gitignore so I don't commit Eclipse files.

#########################

And, after some stumbling, having Eclipse not able to push or pull, I realized I had to add github.com to my ~/.ssh/config file. 8^)





pom.xml changes ...

persistence.xml <--- configures hibernate, lists all the persistent entities

JPAUtility.java <--- get the entity manager for our "persistence unit"

Adversary.java
    -- Add @Entity (get the table name correct)
    -- Add @Id
    -- define all columns (note dropItemName is DropItem in the table)
 
    -- @Transient on dropItem field
    
    -- add a @PostLoad to set the dropItem based on the Uniqueitems
    --- basically moving functionality from the LocationDAO

    @PostLoad 
    protected void postLoad() {
            if (null != dropItemName) {
                setItem(Arrays
                        .stream(UniqueItems.values())
                        .filter(item -> item.getName().equals(dropItemName))
                        .findFirst()
                        .orElse(null)
                );
            }
    }
 
LocationDao.java

Tweak query to not return all adversary info.
Instead:

                                EntityManager em = JPAUtility.getEntityManager();
                                Adversary adversary = em.find( Adversary.class, result.getLong( "AdversaryId" ) );
                            location.setAdversary(adversary);
                            System.out.println("Set adversary " + adversary.getName() + " to location " + location.getName() );

Just get the adversary and set it.



LATER:

Code in Adversary.java about mapping to a dropItemName could be done by persisting the enum in the database.


DAY 2:

#1 Why doesn't JPAUtility work -- wonky IntelliJ; deleting class and readding and it worked.

Making Location persistent:

Start with Location ....
In the database, Location only has id, Name, Description, and AdversaryId.
In the existing code, the locations are read .... and then the exits are set.

Let's keep with that for now.

EXERCISE 1:  Make Location persistent via JPA ... and set the exits the way they are now.
  And keep Adversary set the way it is now.
  Basically doing the joins in Java.
  So set adversary, exits to be @Transient
  In my code, the Location.treasureChest is only set in the manually built world ... so make that @Transient too
  
  I am removing "getTags" and the "tags" attribute, as it isn't used.
  
  SQL in the entityManager.createQuery is NOT standard SQL --- it's a JPA query language
     a lot like SQL, but you reference Java objects ....
       JPQL <--- Java Persistence Query Language. https://thoughts-on-java.org/jpql/
       
     So to select all objects of type Location ....
       em.createQuery( "SELECT loc FROM org.improving.tag.Location loc" ).getResultList().
     Note the reference to the Location class in the "FROM" with the full path.
     Note this query returns List<Location> ...
     
  Only changes are in Location, LocationDAO, persistenceXML.
  
  Note that we can be lazy about transactions .... for now ... and not
  start/end transactions, and not close the entityManager.
  
  

Making Exits & Location persistent.
Join Tables (@JoinTable)
@ManyToMany
@OneToMany
@ManyToOne

Transactions
Lazy Loading

Day 3 - Spring-JPA

Convert everything to Spring-JPA (i.e., get rid of DAO's and use Repositories).
